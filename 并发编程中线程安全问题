线程安全的本质：
	1.原子性
	2.可见性
	3.有序性
	
针对这些问题，从多个层面来保证线程的安全：
	首先是在计算机硬件层面：
	
		线程的安全问题从硬件方面来说是基于多核心CPU架构下存在的问题。因为在单核CPU的情况下，所有线程的执行在硬件层都是串行执行的（比如通过
	时间片轮转、优先级调度、FIFO等策略进行统一调度）
	
		在多核CPU架构下，为了充分利用CPU的资源，使用了多线程的技术，但是在CPU的计算任务中都伴随着存储器的使用，就会受到存储器读写能力的限制，
	读写能力最高的存储器是在CPU中的寄存器，速度和CPU相差不大，但是容量极小。
	
	1.原子性
		硬件中的原子性问题是由于在多核CPU中多个线程同时访问同一共享变量，因为每次修改变量的值，都会有读->改->写的操作，会出现两次内存操作，在两次内
	存操作期间会发生什么其他操作是无法预期的，这就会造成原子性问题。
	
		原子性问题的主体：多个线程并行访问同一共享资源的问题。
		
		解决方法：加锁。
		
			（1）加总线锁
				当一个CPU要更新共享资源的时候，其他所有的CPU都处于阻塞状态，这样就可以保证同时只有一个CPU独占了共享资源。
				但是加总线锁会让多个CPU从并行变成串行，严重影响CPU的性能。
			
			（2）加缓存锁
				当一个CPU要更新共享资源的时候，只需要对被缓存的共享资源进行上锁，不用再总线上进行上锁。
				缓存锁通过缓存一致性（MESI）协议保证共享资源操作的原子性。
					MESI（modified、exclusive、shared、invalid）
					M代表已经被修改的缓存数据
					E代表独占的缓存数据
					S代表多个线程共享的缓存数据
					I代表无效的缓存数据
					
					处于M状态的缓存，需要时刻监听所有该缓存数据在总线上对应的主存地址的操作，一旦发现，需要在此操作发生前把缓存的数据写到主存中去。
					处于E状态的缓存，需要时刻监听其他试图读取该缓存对应的主存地址的操作，一旦发现，就把状态E改为状态S
					处于S状态的缓存，需要时刻监听使该缓存无效或者独占该缓存的操作，一旦发现，把状态S改为状态I
					处于I状态的缓存，当监听到读取该缓存的操作时，是直接在主存中去读取，然后存到缓存中，把状态I改为状态S
					
					CPU在读数据时，如果缓存行的状态是I，就到主存中读数据，然后写入缓存，修改状态为S；如果不是I，就等待其他CPU的监听结果，如果有M状态
				的缓存，就要等待其把数据写入到缓存后才能在主存中重新读取缓存；如果监听结果没有M状态，就可以直接读取缓存中的数据。
					
					CPU在写数据时，需要缓存行的状态是M或者E才能执行。如果不是的话，需要发送特殊的总线事务命令RFO，通知其他CPU将对应主存地址的缓存行
				状态置为I，然后才能修改数据，修改完之后把缓存行的状态改为M。
					
					缓存锁也不是所有的情况都适用。如果一个共享资源被多个CPU频繁的修改，那么就会产生很多的RFO，就会影响到并发的性能。
					和多线程不一定就能提高效率的情况相似，如果线程的调度开销比执行的开销还大，多线程就没办法提高执行效率，甚至会降低效率。
					缓存锁也类似，如果CPU之间调度不合理，那么出现RFO的执行开销大于任务开销的情况，反而引起效率的降低。
		
	2.可见性
		使用共享内存作为数据的通讯方式，就会出现可见性问题。主存上的数据被缓存到寄存器上，CPU使用数据是直接在寄存器上进行读写的，不是直接从主存上去读取。
	当多个线程同时使用共享内存中的数据时，CPU在寄存器上对数据的修改并不会直接反应到对应的主存地址中，就会造成CPU的乱序访问，从而导致可见性问题。
		
		在使用MESI协议保证操作原子性时，因为每一次CPU对寄存器中数据的修改，都会对所有持有该数据的CPU传递修改数据的消息；然后让其他CPU修改持有数据的状态；
	当所有CPU都相应了之后，主存中的数据修改就可以提交成功。这样会造成在消息传递和响应的时候CPU都处于闲置状态。降低了CPU的效率。
	
		可见性问题主体：在寄存器和主存之间加入存储缓存后，CPU内存 的乱序访问造成的可见性问题。
		解决方法：设置内存屏障
			（1）读屏障
				写在读屏障之后的读操作，都必须在读屏障执行完之后才能执行。
			（2）写屏障
				在写屏障之前所有的存储缓存中的数据，都必须写入到主存中之后才能执行写屏障之后的操作。
			（3）全屏障
				屏障前进行的读写操作必须要同步到主存后才能进行屏障之后的操作。
				
		